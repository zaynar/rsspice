//
// GENERATED FILE
//

use super::*;
use f2rust_std::*;

const NITEMS: i32 = 17;
const E1: i32 = 10;
const E2: i32 = 100;
const E3: i32 = 300;

//$Procedure  F_MOVED ( Family of tests for MOVED )
pub fn F_MOVED(OK: &mut bool, ctx: &mut Context) -> f2rust_std::Result<()> {
    let mut BUFF = StackArray::<f64, 17>::new(1..=NITEMS);
    let mut BUFF2 = StackArray::<f64, 17>::new(1..=NITEMS);
    let mut XBUFF = StackArray::<f64, 17>::new(1..=NITEMS);
    let mut IC = StackArray::<i32, 34>::new(1..=(2 * NITEMS));
    let IC2 = StackArray::<i32, 34>::new(1..=(2 * NITEMS));
    let mut MAXP: i32 = 0;
    let mut XIC = StackArray::<i32, 2>::new(1..=2);

    //
    // SPICELIB functions
    //

    //
    // Local parameters
    //

    //
    // Local variables
    //

    //
    // EQUIVALENCE statements
    //

    //
    // Initial values
    //

    //
    // Begin every test family with an open call.
    //
    testutil::TOPEN(b"F_MOVED", ctx)?;

    //
    // Case 1.
    //
    testutil::TCASE(b"Test MOVED for a selection of standard d.p. numbers.", ctx)?;

    BUFF[1] = 1.0;
    BUFF[2] = -1.0;
    BUFF[3] = 0.0;
    BUFF[4] = f64::powi(10.0, E1);
    BUFF[5] = f64::powi(10.0, -E1);
    BUFF[6] = -f64::powi(10.0, E1);
    BUFF[7] = -f64::powi(10.0, -E1);
    BUFF[8] = f64::powi(10.0, E2);
    BUFF[9] = f64::powi(10.0, -E2);
    BUFF[10] = -f64::powi(10.0, E2);
    BUFF[11] = -f64::powi(10.0, E2);
    BUFF[12] = f64::powi(10.0, E3);
    BUFF[13] = f64::powi(10.0, -E3);
    BUFF[14] = -f64::powi(10.0, E3);
    BUFF[15] = -f64::powi(10.0, -E3);
    BUFF[16] = spicelib::DPMAX();
    BUFF[17] = spicelib::DPMIN();

    XBUFF[1] = 1.0;
    XBUFF[2] = -1.0;
    XBUFF[3] = 0.0;
    XBUFF[4] = f64::powi(10.0, E1);
    XBUFF[5] = f64::powi(10.0, -E1);
    XBUFF[6] = -f64::powi(10.0, E1);
    XBUFF[7] = -f64::powi(10.0, -E1);
    XBUFF[8] = f64::powi(10.0, E2);
    XBUFF[9] = f64::powi(10.0, -E2);
    XBUFF[10] = -f64::powi(10.0, E2);
    XBUFF[11] = -f64::powi(10.0, E2);
    XBUFF[12] = f64::powi(10.0, E3);
    XBUFF[13] = f64::powi(10.0, -E3);
    XBUFF[14] = -f64::powi(10.0, E3);
    XBUFF[15] = -f64::powi(10.0, -E3);
    XBUFF[16] = spicelib::DPMAX();
    XBUFF[17] = spicelib::DPMIN();

    spicelib::MOVED(BUFF.as_slice(), NITEMS, BUFF2.as_slice_mut());
    testutil::CHCKXC(false, b" ", OK, ctx)?;

    testutil::CHCKAD(
        b"BUFF2",
        BUFF2.as_slice(),
        b"=",
        XBUFF.as_slice(),
        NITEMS,
        0.0,
        OK,
        ctx,
    )?;

    //
    // Case 2.
    //
    testutil::TCASE(b"Test MOVED for a case known to be problematic.", ctx)?;

    DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[1] = -771000;
    DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[2] = -771900;

    XIC[1] = -771000;
    XIC[2] = -771900;

    spicelib::MOVED(BUFF.as_slice(), 1, BUFF2.as_slice_mut());
    testutil::CHCKXC(false, b" ", OK, ctx)?;

    testutil::CHCKAI(
        b"IC2",
        DummyArray::<i32>::from_equiv(BUFF2.as_slice(), 1..=(2 * NITEMS)).as_slice(),
        b"=",
        XIC.as_slice(),
        2,
        OK,
        ctx,
    )?;

    //
    // Case 3.
    //
    testutil::TCASE(b"Test MOVED for a selection of bit patterns generated by equivalencing 2-integer arrays with dp. numbers.", ctx)?;

    MAXP = (f64::log10((spicelib::INTMAX() as f64)) as i32);

    for I in -1..=(MAXP + 1) {
        //
        // Assign the first element of the IC array.
        //
        if (I == -1) {
            DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[1] = 0;
        } else if (I == (MAXP + 1)) {
            DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[1] =
                spicelib::INTMAX();
        } else {
            DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[1] =
                intrinsics::pow(10, I);
        }

        for J in -1..=(MAXP + 1) {
            //
            // Assign the second element of the IC array.
            //
            if (J == -1) {
                DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[2] = 0;
            } else if (J == (MAXP + 1)) {
                DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[2] =
                    spicelib::INTMAX();
            } else {
                DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[2] =
                    intrinsics::pow(10, J);
            }

            //
            // Try every sign combination.
            //
            for K in 1..=2 {
                DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[1] =
                    (DummyArray::<i32>::from_equiv(BUFF.as_slice(), 1..=(2 * NITEMS))[1]
                        * intrinsics::pow(-1, K));

                for H in 1..=2 {
                    DummyArrayMut::<i32>::from_equiv(BUFF.as_slice_mut(), 1..=(2 * NITEMS))[2] =
                        (DummyArray::<i32>::from_equiv(BUFF.as_slice(), 1..=(2 * NITEMS))[2]
                            * intrinsics::pow(-1, H));
                    //
                    // Test MOVED on the current artificially constructed
                    // d.p. variable.
                    //
                    spicelib::MOVEI(
                        DummyArray::<i32>::from_equiv(BUFF.as_slice(), 1..=(2 * NITEMS)).as_slice(),
                        2,
                        XIC.as_slice_mut(),
                    );
                    spicelib::MOVED(BUFF.as_slice(), 1, BUFF2.as_slice_mut());

                    testutil::CHCKXC(false, b" ", OK, ctx)?;

                    testutil::CHCKAI(
                        b"IC2",
                        DummyArray::<i32>::from_equiv(BUFF2.as_slice(), 1..=(2 * NITEMS))
                            .as_slice(),
                        b"=",
                        XIC.as_slice(),
                        2,
                        OK,
                        ctx,
                    )?;
                }
            }
            //
            // We're done testing the current pair of integers for each
            // sign combination.
            //
        }
    }

    //
    // Case 4.
    //
    testutil::TCASE(b"Test MOVED for NDIM = 0 and -1.", ctx)?;

    spicelib::FILLD(1.0, NITEMS, BUFF.as_slice_mut());

    spicelib::CLEARD(NITEMS, BUFF2.as_slice_mut());
    spicelib::CLEARD(NITEMS, XBUFF.as_slice_mut());

    spicelib::MOVED(BUFF.as_slice(), 0, BUFF2.as_slice_mut());

    testutil::CHCKXC(false, b" ", OK, ctx)?;

    testutil::CHCKAD(
        b"BUFF2",
        BUFF2.as_slice(),
        b"=",
        XBUFF.as_slice(),
        NITEMS,
        0.0,
        OK,
        ctx,
    )?;

    spicelib::MOVED(BUFF.as_slice(), -1, BUFF2.as_slice_mut());

    testutil::CHCKXC(false, b" ", OK, ctx)?;

    testutil::CHCKAD(
        b"BUFF2",
        BUFF2.as_slice(),
        b"=",
        XBUFF.as_slice(),
        NITEMS,
        0.0,
        OK,
        ctx,
    )?;

    testutil::T_SUCCESS(OK, ctx);
    Ok(())
}
