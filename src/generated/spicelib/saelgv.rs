//
// GENERATED FILE
//

use super::*;
use crate::SpiceContext;
use f2rust_std::*;

/// Semi-axes of ellipse from generating vectors
///
/// Find semi-axis vectors of an ellipse generated by two arbitrary
/// three-dimensional vectors.
///
/// # Required Reading
///
/// * [ELLIPSES](crate::required_reading::ellipses)
///
/// # Brief I/O
///
/// ```text
///  VARIABLE  I/O  DESCRIPTION
///  --------  ---  --------------------------------------------------
///  VEC1,
///  VEC2       I   Two vectors used to generate an ellipse.
///  SMAJOR     O   Semi-major axis of ellipse.
///  SMINOR     O   Semi-minor axis of ellipse.
/// ```
///
/// # Detailed Input
///
/// ```text
///  VEC1,
///  VEC2     are two vectors that define an ellipse.
///           The ellipse is the set of points in 3-space
///
///              CENTER  +  cos(theta) VEC1  +  sin(theta) VEC2
///
///           where theta is in the interval ( -pi, pi ] and
///           CENTER is an arbitrary point at which the ellipse
///           is centered. An ellipse's semi-axes are
///           independent of its center, so the vector CENTER
///           shown above is not an input to this routine.
///
///           VEC2 and VEC1 need not be linearly independent;
///           degenerate input ellipses are allowed.
/// ```
///
/// # Detailed Output
///
/// ```text
///  SMAJOR,
///  SMINOR   are semi-major and semi-minor axes of the ellipse,
///           respectively.
/// ```
///
/// # Exceptions
///
/// ```text
///  1)  If one or more semi-axes of the ellipse is found to be the
///      zero vector, the input ellipse is degenerate. This case is
///      not treated as an error; the calling program must determine
///      whether the semi-axes are suitable for the program's intended
///      use.
/// ```
///
/// # Particulars
///
/// ```text
///  Two linearly independent but not necessarily orthogonal vectors
///  VEC1 and VEC2 can define an ellipse centered at the origin: the
///  ellipse is the set of points in 3-space
///
///     CENTER  +  cos(theta) VEC1  +  sin(theta) VEC2
///
///  where theta is in the interval (-pi, pi] and CENTER is an
///  arbitrary point at which the ellipse is centered.
///
///  This routine finds vectors that constitute semi-axes of an
///  ellipse that is defined, except for the location of its center,
///  by VEC1 and VEC2. The semi-major axis is a vector of largest
///  possible magnitude in the set
///
///     cos(theta) VEC1  +  sin(theta) VEC2
///
///  There are two such vectors; they are additive inverses of each
///  other. The semi-minor axis is an analogous vector of smallest
///  possible magnitude. The semi-major and semi-minor axes are
///  orthogonal to each other. If SMAJOR and SMINOR are choices of
///  semi-major and semi-minor axes, then the input ellipse can also
///  be represented as the set of points
///
///     CENTER  +  cos(theta) SMAJOR  +  sin(theta) SMINOR
///
///  where theta is in the interval (-pi, pi].
///
///  The capability of finding the axes of an ellipse is useful in
///  finding the image of an ellipse under a linear transformation.
///  Finding this image is useful for determining the orthogonal and
///  gnomonic projections of an ellipse, and also for finding the limb
///  and terminator of an ellipsoidal body.
/// ```
///
/// # Examples
///
/// ```text
///  1)  An example using inputs that can be readily checked by
///      hand calculation.
///
///         Let
///
///            VEC1 = ( 1.D0,  1.D0,  1.D0 )
///            VEC2 = ( 1.D0, -1.D0,  1.D0 )
///
///        The subroutine call
///
///           CALL SAELGV ( VEC1, VEC2, SMAJOR, SMINOR )
///
///        returns
///
///           SMAJOR = ( -1.414213562373095D0,
///                       0.0D0,
///                      -1.414213562373095D0 )
///        and
///
///           SMINOR = ( -2.4037033579794549D-17
///                       1.414213562373095D0,
///                      -2.4037033579794549D-17 )
///
///
///  2)   This example is taken from the code of the SPICELIB routine
///       PJELPL, which finds the orthogonal projection of an ellipse
///       onto a plane. The code listed below is the portion used to
///       find the semi-axes of the projected ellipse.
///
///          C
///          C     Project vectors defining axes of ellipse onto plane.
///          C
///                CALL VPERP ( VEC1,   NORMAL,  PROJ1  )
///                CALL VPERP ( VEC2,   NORMAL,  PROJ2  )
///
///                   .
///                   .
///                   .
///
///                CALL SAELGV ( PROJ1,  PROJ2,  SMAJOR,  SMINOR )
///
///
///       The call to SAELGV determines the required semi-axes.
/// ```
///
/// # Literature References
///
/// ```text
///  [1]  T. Apostol, "Calculus, Vol. II," chapter 5, "Eigenvalues of
///       Operators Acting on Euclidean Spaces," John Wiley & Sons,
///       1969.
/// ```
///
/// # Author and Institution
///
/// ```text
///  N.J. Bachman       (JPL)
///  J. Diaz del Rio    (ODC Space)
///  W.L. Taber         (JPL)
/// ```
///
/// # Version
///
/// ```text
/// -    SPICELIB Version 1.2.0, 28-MAY-2021 (JDR)
///
///         Added IMPLICIT NONE statement.
///
///         Edited the header to comply with NAIF standard.
///
/// -    SPICELIB Version 1.1.1, 22-APR-2010 (NJB)
///
///         Header correction: assertions that the output
///         can overwrite the input have been removed.
///
/// -    SPICELIB Version 1.1.0, 02-SEP-2005 (NJB)
///
///         Updated to remove non-standard use of duplicate arguments
///         in VSCL calls.
///
/// -    SPICELIB Version 1.0.1, 10-MAR-1992 (WLT)
///
///         Comment section for permuted index source lines was added
///         following the header.
///
/// -    SPICELIB Version 1.0.0, 02-NOV-1990 (NJB) (WLT)
/// ```
pub fn saelgv(
    ctx: &mut SpiceContext,
    vec1: &[f64; 3],
    vec2: &[f64; 3],
    smajor: &mut [f64; 3],
    sminor: &mut [f64; 3],
) -> crate::Result<()> {
    SAELGV(vec1, vec2, smajor, sminor, ctx.raw_context())?;
    ctx.handle_errors()?;
    Ok(())
}

//$Procedure SAELGV ( Semi-axes of ellipse from generating vectors )
pub fn SAELGV(
    VEC1: &[f64],
    VEC2: &[f64],
    SMAJOR: &mut [f64],
    SMINOR: &mut [f64],
    ctx: &mut Context,
) -> f2rust_std::Result<()> {
    let VEC1 = DummyArray::new(VEC1, 1..=3);
    let VEC2 = DummyArray::new(VEC2, 1..=3);
    let mut SMAJOR = DummyArrayMut::new(SMAJOR, 1..=3);
    let mut SMINOR = DummyArrayMut::new(SMINOR, 1..=3);
    let mut C = StackArray2D::<f64, 4>::new(1..=2, 1..=2);
    let mut EIGVAL = StackArray2D::<f64, 4>::new(1..=2, 1..=2);
    let mut S = StackArray2D::<f64, 4>::new(1..=2, 1..=2);
    let mut SCALE: f64 = 0.0;
    let mut TMPVC1 = StackArray::<f64, 3>::new(1..=3);
    let mut TMPVC2 = StackArray::<f64, 3>::new(1..=3);
    let mut MAJOR: i32 = 0;
    let mut MINOR: i32 = 0;

    //
    // SPICELIB functions
    //

    //
    // Local variables
    //

    //
    // Standard SPICE error handling.
    //
    if RETURN(ctx) {
        return Ok(());
    } else {
        CHKIN(b"SAELGV", ctx)?;
    }

    //
    //    Let the notation
    //
    //       < a, b >
    //
    //    indicate the inner product of the vectors a and b.
    //
    //    The semi-major and semi-minor axes of the input ellipse are
    //    vectors of maximum and minimum norm in the set
    //
    //       cos(x) VEC1  +  sin(x) VEC2
    //
    //    where x is in the interval (-pi, pi].
    //
    //    The square of the norm of a vector in this set is
    //
    //                                            2
    //           || cos(x) VEC1  +  sin(x) VEC2 ||
    //
    //
    //       =   < cos(x)VEC1 + sin(x)VEC2,  cos(x)VEC1 + sin(x)VEC2 > ;
    //
    //    this last expression can be written as the matrix product
    //
    //        T
    //       X  S  X,                                                 (1)
    //
    //    where X is the unit vector
    //
    //       +-      -+
    //       | cos(x) |
    //       |        |
    //       | sin(x) |
    //       +-      -+
    //
    //    and S is the symmetric matrix
    //
    //       +-                                -+
    //       | < VEC1, VEC1 >    < VEC1, VEC2 > |
    //       |                                  |.
    //       | < VEC1, VEC2 >    < VEC2, VEC2 > |
    //       +-                                -+
    //
    //    Because the 2x2 matrix above is symmetric, there exists a
    //    rotation matrix that allows us to diagonalize it:
    //
    //        T
    //       C  S  C  =  D,
    //
    //    where D is a diagonal matrix.  Since rotation matrices are
    //    orthogonal, we have
    //
    //        T
    //       C  C  =  I.
    //
    //    If the unit vector U is defined by
    //
    //            T
    //       U = C X,
    //
    //    then
    //
    //        T             T  T         T               T
    //       X  S  X  =  ( U  C  )  C D C   ( C U )  =  U  D  U.
    //
    //    So, letting
    //
    //       +-   -+
    //       |  u  |
    //       |     |  =  U,
    //       |  v  |
    //       +-   -+
    //
    //    we may re-write the original quadratic expression (1) as
    //
    //       +-     -+    +-        -+    +-   -+
    //       | u   v |    | D1    0  |    |  u  |,
    //       +-     -+    |          |    |     |
    //                    |          |    |  v  |
    //                    | 0     D2 |    +-   -+
    //                    +-        -+
    //    or
    //
    //           2            2
    //       D1 u    +    D2 v,
    //
    //    where the diagonal matrix above is D.  The eigenvalues D1 and
    //    D2 are non-negative because they are eigenvalues of a positive
    //    semi-definite matrix of the form
    //
    //        T
    //       M  M.
    //
    //    We may require that
    //
    //       D1  >  D2;
    //           -
    //
    //    then the maximum and minimum values of
    //
    //           2            2
    //       D1 u    +    D2 v                                        (2)
    //
    //    are D1 and D2 respectively.  These values are the squares
    //    of the lengths of the semi-major and semi-minor axes of the
    //    ellipse, since the expression (2) is the square of the norm
    //    of the point
    //
    //       cos(x) VEC1  + sin(x) VEC2.
    //
    //    Now we must find some eigenvectors.  Since the extrema of (2)
    //    occur when
    //
    //            +-   -+                     +-   -+
    //            |  1  |                     |  0  |
    //       U =  |     |       or       U =  |     |,
    //            |  0  |                     |  1  |
    //            +-   -+                     +-   -+
    //
    //    and since
    //
    //       X = C U,
    //
    //    we conclude that the extrema occur when X = C1 or X = C2, where
    //    C1 and C2 are the first and second columns of C.  Looking at
    //    the definition of X, we see that the extrema occur when
    //
    //       cos(x) = C1(1)
    //       sin(x) = C1(2)
    //
    //    and when
    //
    //       cos(x) = C2(1),
    //       sin(x) = C2(2)
    //
    //    So the semi-major and semi-minor axes of the ellipse are
    //
    //       C(1,1) VEC1  +  C(2,1) VEC2
    //
    //    and
    //
    //       C(1,2) VEC1  +  C(2,2) VEC2
    //
    //    (the negatives of these vectors are also semi-axes).
    //
    //
    // Copy the input vectors.
    //
    MOVED(VEC1.as_slice(), 3, TMPVC1.as_slice_mut());
    MOVED(VEC2.as_slice(), 3, TMPVC2.as_slice_mut());

    //
    // Scale the vectors to try to prevent arithmetic unpleasantness.
    // We avoid using the quotient 1/SCALE, as this value may overflow.
    // No need to go further if SCALE turns out to be zero.
    //
    SCALE = intrinsics::DMAX1(&[VNORM(TMPVC1.as_slice()), VNORM(TMPVC2.as_slice())]);

    if (SCALE == 0.0) {
        CLEARD(3, SMAJOR.as_slice_mut());
        CLEARD(3, SMINOR.as_slice_mut());

        CHKOUT(b"SAELGV", ctx)?;
        return Ok(());
    }

    for I in 1..=3 {
        TMPVC1[I] = (TMPVC1[I] / SCALE);
        TMPVC2[I] = (TMPVC2[I] / SCALE);
    }

    //
    // Compute S and diagonalize it:
    //
    S[[1, 1]] = VDOT(TMPVC1.as_slice(), TMPVC1.as_slice());
    S[[2, 1]] = VDOT(TMPVC1.as_slice(), TMPVC2.as_slice());
    S[[1, 2]] = S[[2, 1]];
    S[[2, 2]] = VDOT(TMPVC2.as_slice(), TMPVC2.as_slice());

    DIAGS2(S.as_slice(), EIGVAL.as_slice_mut(), C.as_slice_mut(), ctx)?;

    //
    // Find the semi-axes.
    //
    if (f64::abs(EIGVAL[[1, 1]]) >= f64::abs(EIGVAL[[2, 2]])) {
        //
        // The first eigenvector ( first column of C ) corresponds
        // to the semi-major axis of the ellipse.
        //
        MAJOR = 1;
        MINOR = 2;
    } else {
        //
        // The second eigenvector corresponds to the semi-major axis.
        //
        MAJOR = 2;
        MINOR = 1;
    }

    VLCOM(
        C[[1, MAJOR]],
        TMPVC1.as_slice(),
        C[[2, MAJOR]],
        TMPVC2.as_slice(),
        SMAJOR.as_slice_mut(),
    );
    VLCOM(
        C[[1, MINOR]],
        TMPVC1.as_slice(),
        C[[2, MINOR]],
        TMPVC2.as_slice(),
        SMINOR.as_slice_mut(),
    );

    //
    // Undo the initial scaling.
    //
    VSCLIP(SCALE, SMAJOR.as_slice_mut());
    VSCLIP(SCALE, SMINOR.as_slice_mut());

    CHKOUT(b"SAELGV", ctx)?;
    Ok(())
}
