//
// GENERATED FILE
//

use super::*;
use crate::SpiceContext;
use f2rust_std::*;

/// Check ID string
///
/// Validate an ID string: check for non-printing characters
/// or excessive non-blank length.
///
/// # Brief I/O
///
/// ```text
///  VARIABLE  I/O  DESCRIPTION
///  --------  ---  --------------------------------------------------
///  CLASS      I   A description of the class to which ID belongs.
///  MAXLEN     I   Maximum allowed non-blank length of ID.
///  ID         I   The ID string to be validated.
/// ```
///
/// # Detailed Input
///
/// ```text
///  CLASS    is a descriptive string indicating the type of
///           object represented by ID. Examples are
///           'SPK segment identifier', 'DAF internal file name',
///           or 'EK table name'.
///
///           If the input ID is found to be invalid, CLASS is
///           used in the error message generated by this
///           routine.
///
///  MAXLEN   is the maximum allowed non-blank length of the
///           input ID string. If ID has any non-blank
///           characters at positions greater than MAXLEN,
///           an error will be signaled.
///
///  ID       is the input ID string to be checked. In order
///           to be considered valid, ID must contain only
///           printing characters and must satisfy the condition
///
///              LASTNB( ID )  <  MAXLEN
///                            -
/// ```
///
/// # Detailed Output
///
/// ```text
///  None. See $Particulars for a description of the effect of this
///  routine.
/// ```
///
/// # Exceptions
///
/// ```text
///  1)  If ID contains any nonprintable characters, the error
///      SPICE(NONPRINTABLECHARS) is signaled.
///
///  2)  If MAXLEN is non-positive, the error SPICE(INVALIDCOUNT) is
///       signaled.
///
///  3)  If ID contains any non-blank characters past position
///      MAXLEN, the error SPICE(IDSTRINGTOOLONG) is signaled.
///
///  4)  If CLASS contains any non-printing characters, the error
///      SPICE(NONPRINTABLECHARS) is signaled.
///
///  5)  CLASS is allowed to be blank. The word 'ID' is used in
///      place of the class string in any error messages in this
///      case.
///
///  6)  The error messages output by this routine have a maximum
///      length of 320 characters. If substitution of CLASS and
///      ID into the long messages causes overflow, the messages
///      will be truncated on the right.
/// ```
///
/// # Particulars
///
/// ```text
///  This routine operates by side effects: it validates an ID string
///  and signals an error if the ID has either of the following
///  problems:
///
///  -  There are non-printing characters in the ID string.
///
///  -  The last non-blank character in the string occurs at a
///     location having index higher than a specified value.
///
///  The error message signaled by this routine contains the offending
///  ID string and indicates the class of item to which ID belongs.
///  The form of the message is:
///
///      The <CLASS> <'ID'> is invalid; <reason>
/// ```
///
/// # Examples
///
/// ```text
///  1)  If
///
///         CLASS  = 'segment identifier'
///         MAXLEN =  40
///
///      and
///
///         ID = 'Example EK created on March 28, 1995 by NJB/NAIF'
///
///      the error message
///
///         The segment identifier 'Example EK created on March 28,
///         1995 by NJB/NAIF' is invalid; the last non-blank character
///         is located at position 48.
///
///      will be signaled.
/// ```
///
/// # Author and Institution
///
/// ```text
///  N.J. Bachman       (JPL)
///  J. Diaz del Rio    (ODC Space)
/// ```
///
/// # Version
///
/// ```text
/// -    SPICELIB Version 1.1.0, 02-JUN-2021 (JDR)
///
///         Added IMPLICIT NONE statement.
///
///         Edited the header to comply with NAIF standard.
///
/// -    SPICELIB Version 1.0.0, 16-JUN-1995 (NJB)
/// ```
pub fn chckid(ctx: &mut SpiceContext, class: &str, maxlen: i32, id: &str) -> crate::Result<()> {
    CHCKID(class.as_bytes(), maxlen, id.as_bytes(), ctx.raw_context())?;
    ctx.handle_errors()?;
    Ok(())
}

//$Procedure CHCKID ( Check ID string )
pub fn CHCKID(CLASS: &[u8], MAXLEN: i32, ID: &[u8], ctx: &mut Context) -> f2rust_std::Result<()> {
    let mut CHRCOD: i32 = 0;
    let mut I: i32 = 0;
    let mut L: i32 = 0;

    //
    // SPICELIB functions
    //

    //
    // Local variables
    //

    //
    // Standard SPICE error handling.
    //
    if RETURN(ctx) {
        return Ok(());
    } else {
        CHKIN(b"CHCKID", ctx)?;
    }

    //
    // Check CLASS before trying to use it in an error message.
    //
    I = FRSTNP(CLASS);

    if (I > 0) {
        CHRCOD = intrinsics::ICHAR(fstr::substr(CLASS, I..=I));

        SETMSG(b"The class string \'#\' is invalid; this string contains a non-printing character (ICHAR = #) at position #.", ctx);
        ERRCH(b"#", CLASS, ctx);
        ERRINT(b"#", CHRCOD, ctx);
        ERRINT(b"#", I, ctx);
        SIGERR(b"SPICE(NONPRINTABLECHARS)", ctx)?;
        CHKOUT(b"CHCKID", ctx)?;
        return Ok(());
    }

    //
    // MAXLEN must be a sensible value.
    //
    if (MAXLEN < 1) {
        SETMSG(
            b"Non-blank length limit MAXLEN should be positive but was #.",
            ctx,
        );
        ERRINT(b"#", MAXLEN, ctx);
        SIGERR(b"SPICE(INVALIDCOUNT)", ctx)?;
        CHKOUT(b"CHCKID", ctx)?;
        return Ok(());
    }

    L = LASTNB(ID);

    //
    // The ID must not be too long.
    //
    if (L > MAXLEN) {
        SETMSG(b"The # \'#\' is invalid; the last non-blank character is located at position #; the maximum allowed length is #.", ctx);

        if fstr::ne(CLASS, b" ") {
            ERRCH(b"#", CLASS, ctx);
        } else {
            ERRCH(b"#", b"ID", ctx);
        }

        ERRCH(b"#", ID, ctx);
        ERRINT(b"#", L, ctx);
        ERRINT(b"#", MAXLEN, ctx);
        SIGERR(b"SPICE(IDSTRINGTOOLONG)", ctx)?;
        CHKOUT(b"CHCKID", ctx)?;
        return Ok(());
    }

    //
    // Look for non-printing characters in ID.
    //
    I = FRSTNP(ID);

    if (I > 0) {
        CHRCOD = intrinsics::ICHAR(fstr::substr(ID, I..=I));

        SETMSG(b"The # \'#\' is invalid; this string contains a non-printing character (ICHAR = #) at position #.", ctx);

        if fstr::ne(CLASS, b" ") {
            ERRCH(b"#", CLASS, ctx);
        } else {
            ERRCH(b"#", b"ID", ctx);
        }

        ERRCH(b"#", ID, ctx);
        ERRINT(b"#", CHRCOD, ctx);
        ERRINT(b"#", I, ctx);
        SIGERR(b"SPICE(NONPRINTABLECHARS)", ctx)?;
        CHKOUT(b"CHCKID", ctx)?;
        return Ok(());
    }

    CHKOUT(b"CHCKID", ctx)?;
    Ok(())
}
